<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Chapter 3 :: Collections</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div id="sidebar">
  <div class="sidebar-entry"><a href="01_01.html">Preface :: Fearless: Zero to Hero</a></div>
<div class="sidebar-entry"><a href="02_01.html">Chapter 1 :: Directions</a></div>
<div class="sidebar-entry"><a href="03_01.html">Chapter 1 :: Basic code reuse</a></div>
<div class="sidebar-entry"><a href="04_01.html">Chapter 1 :: Rotations</a></div>
<div class="sidebar-entry"><a href="05_01.html">Chapter 1 :: Finite numbers</a></div>
<div class="sidebar-entry"><a href="06_01.html">Chapter 1 :: Strings</a></div>
<div class="sidebar-entry"><a href="07_01.html">Chapter 1 :: Types and Meaning</a></div>
<div class="sidebar-entry"><a href="08_01.html">Chapter 1 :: Terminology Recap</a></div>
<div class="sidebar-entry"><a href="09_01.html">Chapter 2 :: Generic Types</a></div>
<div class="sidebar-entry"><a href="10_01.html">Chapter 2 :: Booleans</a></div>
<div class="sidebar-entry"><a href="11_01.html">Chapter 2 :: Optionals</a></div>
<div class="sidebar-entry"><a href="12_01.html">Chapter 2 :: Peano numbers</a></div>
<div class="sidebar-entry"><a href="13_01.html">Chapter 2 :: Stack</a></div>
<div class="sidebar-entry"><a href="14_01.html">Chapter 2 :: Operations on Sequences</a></div>
<div class="sidebar-entry"><a href="15_01.html">Chapter 2 :: Locals</a></div>
<div class="sidebar-entry"><a href="16_01.html">Chapter 2 :: Tanks Game</a></div>
<div class="sidebar-entry"><a href="17_01.html">Chapter 3 :: ImplementingFromScratch</a></div>
<div class="sidebar-entry"><a href="18_01.html">Chapter 3 :: Promotions</a></div>
<div class="sidebar-entry"><a href="19_01.html">Chapter 3 :: Packages</a></div>
<div class="sidebar-entry"><a href="20_01.html">Chapter 3 :: ObjectCapabilities</a></div>
<div class="sidebar-entry"><a href="21_01.html">Chapter 3 :: NewOptBool</a></div>
<div class="sidebar-entry"><a href="22_01.html">Chapter 3 :: Show Tanks</a></div>
<div class="sidebar-entry"><a href="23_01.html">Chapter 3 :: Show All Tanks</a></div>
<div class="sidebar-entry"><a href="24_01.html">Chapter 3 :: Collections</a></div>

  </div>
  <div id="content" class="markdown-content">
<h2>Flows and related data types</h2>
<p>As you can see, In Chapter 2 we showed how to build our own <code>Stack[E]</code> by hand and how to make the tank game using our own stack and <code>.map</code> methods. Here in Chapter 3 we have shown <code>List[E]</code> and how to make the tank game using <code>Flow[E]</code>.
We will conclude Chapter 3 showing many useful examples of flows and related data types, and many nice ways they can be used.</p>
<h2>Method <code>.map</code></h2>
<p>Flows can be used to transform lists in other lists.
When focusing on this aspect, it is important to keep in mind the size of the lists:
If the output list is supposed to be of the same size as the input list, we can use map.
For example:</p>
<pre><code>Person:{ .name:Str, }
...
Names:{  #(ps: List[Person]): List[Str] -&gt; ps.flow.map{::name }.list   }
</code></pre>
<p>The code above uses <code>.map</code> to turn the list of persons <code>ps</code> into a list containing just the names of those persons.
The code above uses again the <code>::</code> sugar. <code>{::name}</code> is equivalent to <code>{p-&gt;p.name}</code>.
Note the common pattern: we call <code>.flow</code> on our list, we call one or more operations (map in this case),
and finally call <code>.list</code> to collect the result into a new list.</p>
<h2>Method <code>.filter</code></h2>
<p>Sometimes we have elements that we do not like.
We can use <code>.filter</code> to take them away. For example:</p>
<pre><code>Person:{ .name:Str, }
...
Doctors:{ #(ps: List[Person]): List[Person] -&gt;ps.flow.filter{::name.startsWith `Dr.` }.list }
</code></pre>
<p>Here we only keep the persons whose name starts with <code>`Dr.`</code>.
That is, the list in output is always going to contain only elements from the original list; but not all elements may be present. Thus the list in output may be shorter than the list in input. Again, the size of the input/output guides our reasoning.</p>
<h2>Method <code>.flatMap</code></h2>
<p>Sometimes we want even more elements.
We can use <code>.flatMap</code>. For example:</p>
<pre><code>Person:{  .name:Str, .cats: List[Cat],  }
Cat:{ .name: Str, }
...
AllCats:{  #(ps: List[Person]): List[Cat] -&gt; ps.flow.flatMap{::cats.flow }.list  }
</code></pre>
<p>Here we extract all the cats owned by the persons in the list.
Note how we use  <code>{::cats.flow}</code> and not just <code>{::cats}</code>. Method <code>.flatMap</code> requires a lambda returning a flow.
In this example we also see how we change the type of our list: we take a <code>List[Person]</code> in input and we produce a <code>List[Cat]</code> in output.
While <code>.flatMap</code> is often used to add elements, it may also remove them. For example, if all the persons in the input list have no cats, the output will be the empty list.</p>
<h2>Method <code>.join</code></h2>
<p>We have seen how flows can be used to transform lists into other lists.
There are also many ways to extract single values from flows.
Flows of strings can be joined into a single string by providing the separator.
For example:</p>
<pre><code>Person:{ .name:Str, }
...
AllNames:{ #(ps: List[Person]): Str -&gt;ps.flow.map{::name }.join `, ` }
</code></pre>
<p>The code above first uses <code>.map</code> to extra the names of all the persons, and then joins all the names together; separated by the &quot;comma and space&quot; characters.</p>
<p>We can also compute the sum of the size of all the names as follows:</p>
<pre><code>Person:{ .name:Str, }
...
SumSizes:{ #(ps: List[Person]): Str -&gt;ps.flow.map{::name.size }.join 0 }
</code></pre>
<p>This sums all the sizes of all the names starting from zero.
That is, <code>.join</code> is a flexible method that can compose many different kinds of values and the values know how to be composed together. Simple and Unicode string and all number types are joinable. We will see a few other joinable types later in this guide</p>
<h2>Method <code>.fold</code></h2>
<p>A typical operation is to extract the &quot;best&quot; element from a flow.
But, what makes something the best? We can use the <code>.fold</code> method and accumulate the best element using an <code>.if</code>, as shown in the code below.</p>
<pre><code>Person:{ .name:Str, .cats: List[Cat], }
Cat:{ .name: Str, }
...
Nicer :{ #(bob: Person, ps: List[Person]): Person-&gt;ps.flow
  .fold(bob, {acc, p -&gt; 
    p.cats.size &gt;= (bob.cats.size) .if {.then-&gt;p, .else-&gt;bob,  } 
  }}
</code></pre>
<p>The .fold works pretty much in the same way of the .fold method we have seen on the stack.
The method takes two parameters: an initial value and a lambda accumulating elements on that value.</p>
<h2>Methods <code>.any</code>, <code>.all</code>, <code>.none</code></h2>
<p>We often want to extract a boolean value from a flow by searching if some elements respect a predicate.</p>
<pre><code>Person:{ .name:Str, .cats: List[Cat]}
Cat:{ .name: Str, }
...
Sad :{ #(ps: List[Person]): Bool -&gt; ps.flow.any{::cats.isEmpty  } }
</code></pre>
<p>The <code>.any</code> checks if any of the elements satisfy the predicate <code>{::cats.isEmpty}</code>.
That is, the predicate is just a function returning a boolean.
Here we are searching if there is a person that sadly lacks cats.
This operation does not mindlessly search all the persons, as soon as the first catless person is found, we have our answer and we can return a result without any more searching.
Similarly, <code>.none</code> is true only if none of the elements respect the predicate.
Method <code>.all</code> instead checks that all of the elements respect the predicate, and it stops when it finds an element that does not.</p>
<h3>Lists</h3>
<p>We have seen that we can call <code>.list</code> to produce a list out of our flows.
We can also use <code>Lists#(a,b,c,d...)</code> to create lists directly.
Lists are similar to the Stacks we discussed before, but they have different functionalities:</p>
<h1>Limited size and failures:</h1>
<p>Lists contain any number of elements, from 0 up to the maximum positive number represented by an <code>Int</code>.
That is a big but not  unlimited number, and flows could in principle contain many more elements than that. This means that some operations may fail when we can not make a list with a number of elements bigger than that limit. For example <code>myFlow.list</code> may fail to create a list big enough to store all the elements of the flow.</p>
<p>A Fearless method can indicate failure by throwing an error.
Errors are not part of the basic semantic of Fearless, and they can be thrown using magic methods or convenience methods using magic methods internally.
For example, the method <code>Error.msg(Str)</code> will throw an error using that string as an error message, plus some more debugging information.
When a method throws an error the computation stops and the error is reported outside of the program. That is, the whole Fearless application stops and burns.
This is often undesirable, thus this behaviour can be overridden using
<code>Try#{ ../*code that can fail*/.. }</code>. We will discuss the details of Try later, and for now we will assume all errors to simply obliterate the running code.</p>
<h1>Core List methods for Random Access: .size, .isEmpty and .get</h1>
<p>With our home made Stack, the only way to compute the amount of elements in the stack is to explore the whole stack and manually count the elements one by one.
Lists offers a method <code>List[E].size</code> that can return the number of elements in the list without the need of counting them. The size information is simply stored directly. For convenience, there is also a method <code>isEmpty</code> equivalent to calling <code>myList.size==0</code>.</p>
<p>The method <code>List.get(i: Nat)</code> either returns the element in index <code>i</code> or uses <code>Error.msg(..)</code> to report the lookup failure.
This is particularly convenient for many applications if you can tolerate the continuous risk of failure.
Flow operations are especially effective when the exact positions of the elements in the list are not crucial.
However, when elements are arranged in a specific sequence, accessing them via index becomes essential. In a list, indexing starts from zero and ends at size -1. Thus, in a list of 5 elements, the indices are as follows:</p>
<ul>
<li>The first element is at index 0,</li>
<li>The second at index 1,</li>
<li>The third at index 2,</li>
<li>The fourth at index 3,</li>
<li>The fifth and last at index 4.</li>
</ul>
<p>This zero-based indexing system has beneficial mathematical properties. For example, it allows a single list to efficiently emulate a grid structure. Consider a 3x5 grid as depicted below, where <code>x</code> ranges from 0 to 4 (columns) and <code>y</code> from 0 to 2 (rows). Each cell <code>(x, y)</code> corresponds to the <strong>single index</strong> <code>index = y * 5 + x</code> in a flat list of length 15:</p>
<pre><code> x,y                          --&gt;  index mapping
 0,0 | 1,0 | 2,0 | 3,0 | 4,0  --&gt;   0 |  1 |  2 |  3 |  4
 0,1 | 1,1 | 2,1 | 3,1 | 4,1  --&gt;   5 |  6 |  7 |  8 |  9
 0,2 | 1,2 | 2,2 | 3,2 | 4,2  --&gt;  10 | 11 | 12 | 13 | 14 
</code></pre>
<p>This grid shows how a two-dimensional coordinate system (x, y) can be flattened into a single list index. For example, (3, 1) maps to index 8, since it’s the 4th element in the 2nd row of a 5-column grid.</p>
<p>That is, we can encode this grid in a single list.
The element in position <code>x, y</code> can be accessed using the formula
<code>index = y * 5 + x</code>, where 5 is the number of columns in the grid.</p>
<p>On the other side, if we have the <code>index</code> , we can recover the original <code>x, y</code> coordinates as:
<code>y = index / 5</code> and <code>x = index modulo 5</code>
This bidirectional mapping makes it easy to simulate a 2D grid using a flat array.</p>
<p>A type representing the grid could look like this:</p>
<pre><code>Grid:{
  .inner: List[Elem],
  .get(x: Nat, y: Nat): Elem -&gt; this.inner.get(y * 5 + x),
  .y(index: Nat): Nat -&gt; index / 5,
  .x(index: Nat): Nat -&gt; index.mod(5),
  }
</code></pre>
<p>Note: since <code>index</code> is a Nat, the division is rounded down (<strong>integer division</strong>).
For example <code>12/5 = 2</code>; and the modulo/<code>.mod</code> operation returns the reminder of the
integer division: <code>12 modulo 5 = 2</code></p>
<p>This kind of encoding was crucial in the past for extracting performance benefits from primitive machines with severe memory constraints. Today, while less common, it remains critical in some contexts.</p>
<h1>The <code>.as</code> method</h1>
<p><code>List[E].as</code> is a method creating a new list where the elements have gone through some kind of transformation.
That is, the following three expressions are equivalent:</p>
<pre><code>  List#(`3`,`4`,`5`)
  List#(1,2,3).as{::+ 2 .str}
  List#(1,2,3).flow.map{::+ 2 .str}.list
</code></pre>
<p>While method <code>List[E].as</code> mostly behaves as <code>.flow.map.list</code>, the compiler can optimise it to run faster in a few crucial cases.</p>
<h1>Lists and mutability.</h1>
<p>Stacks as shown before are always immutable, while lists support both mutable and immutable elements.
Note how there are now two reference capabilities in play:
the capability of the list and the capability of the elements. This gives us a range of possible list types.</p>
<p>Clear and useful options:</p>
<ul>
<li>
<p><code>List[Num]</code> is an immutable list of immutable numbers. It can also be written as <code>imm List[imm Num]</code> since <code>imm</code> is the default.
You can think of it as a hard container of hard elements. For example a wooden plank with coins permanently glued into it.</p>
</li>
<li>
<p><code>mut List[mut Animal]</code> is a list of mutable animals.
Since reference capabilities impact the whole reachable object graph, an object storing mutable objects needs to be mutable too.
Thus, we need to use <code>mut</code> twice.
Using <code>.get</code> we can obtain <code>mut</code> references to the contained animals and mutate them.
If we have a binding <code>animals</code> containing <code>[bunny,bunny]</code>; that is, the same bunny twice, we can call <code>animals.get(0).run</code> and the bunny will mutate; it will now be in a new position. Since the same bunny is contained in the list twice, <code>animals.get(1).location</code> will also result in the same updated location.
You can think of it as a hard container of soft elements, for example a table with soft and malleable clay sculptures on top.</p>
</li>
</ul>
<p>Unclear and confusing options:
In addition to the two options above, there are a few other permutations. Those should not be used in actual programs, since better more clear types are available.</p>
<ul>
<li><code>mut List[Num]</code> is a list of immutable numbers. Here the fact that the list is mutable does not have any effect, since the contained numbers are immutable anyway. Types like this may emerge when using generics:
Consider the following code:</li>
</ul>
<pre><code>  .m[X:*](f: mut MF[X]):mut List[X]-&gt;Lists#(f#,f#,f#)
</code></pre>
<p>This code creates a list by repeatedly using the mutable function <code>f</code>.
When calling this code with <code>X=Num</code>, we would produce a <code>mut List[Num]</code>.
If we can not promote this result to <code>imm</code>, we can convert it to <code>imm</code> by doing <code>myList.as{::}</code>.
There <code>{::}</code> will be desugared as <code>F[Num,Num]{a-&gt;a}</code>. That is, a simple identity function, mapping the elements to themselves. Since method .as returns an <code>imm List</code>, we are effectively converting the <code>mut List[E]</code> into an <code>imm List[E]</code>.
This and a few other patterns are also optimised by the compiler to not create a new object but reuse the old one. Basically by calling this method we are guiding the type system.</p>
<ul>
<li><code>List[mut Animal]</code>, also written as <code>imm List[mut Animal]</code> behaves exactly like a <code>List[Animal]</code>, that is, an immutable list of immutable elements, but the type system does not know about this. As for before, if we have an <code>animals: List[mut Animal]</code> and we need a <code>List[Animal]</code> we can just call <code>animals.as{::}</code>.
This last case often emerges from promotion: we may start with a <code>mut List[mut Animal]</code> and then turn it into immutable.</li>
</ul>
<h1>Other core list methods: <code>+</code>, <code>++</code>, <code>.subList</code></h1>
<p>We can concatenate lists and elements using methods <code>++</code> and <code>+</code>.
The expression below are all equivalent:</p>
<pre><code>List#(1,2,3,4)
List#(1,2) + 3 + 4
List#(1,2) ++ List(3,4)
List#(1) ++ List(2,3,4)
</code></pre>
<p>As you can see, we use <code>+</code> to concatenate list and element, and <code>++</code> to concatenate two lists.
Since <code>+</code> is a method of list, the following code does not work:</p>
<pre><code>1 + List(2,3,4)
</code></pre>
<p>We need to instead wrap the <code>1</code> in a singleton list, as shown above.</p>
<p>Finally, we can use <code>.subList(start,end)</code> to get a sub part of a list. Method <code>.subList</code> does not clone the list, but creates a minimal wrapper object referring to the transformed indexes; thus using <code>.subList</code> on a very, very long list is still a cheap operation.</p>
<p>Note that methods <code>+</code>, <code>++</code> and <code>.subList</code> are all designed to work with immutable lists only.</p>
<h1>List and withers: <code>.with</code>, <code>.without</code>, <code>.withAlso</code></h1>
<p>Suppose we have a list of 10 tanks, and we want to insert a new tank in the middle.
We could do <code>tanks.sublist(0,5)+ newTank++tanks.sublist(5,10)</code>, but it is verbose and counter intuitive.
The <code>List[E]</code> type offers dedicated methods for those kinds of operation.
To obtain the desired result we can just write <code>tanks.withAlso(5,newTank)</code>.
If we wanted to replace the tank in position 5, we could write <code>tanks.with(5,newTank)</code>; and if we wanted to remove the tank in position 5 to get a list of only 9 tanks, we could write <code>tanks.without(5)</code>.</p>
<p>Note how those 3 methods do not mutate the current list but create a new List that looks like the old one but with one specific change.
This is the recommended way to handle lists in Fearless, but in the rare case where either performance or observing mutation via aliasing is crucial, you can use the type <code>UList[E]</code> (updatable list) allowing to add, remove and update elements in place.
Sometimes <code>UList[E]</code> is used as a builder/accumulator to eventually create a List. Since using <code>UList[E]</code> is quite rare we do not discuss it here in detail.</p>
<h3>Comparators and equality</h3>
<blockquote>
<p>NOTE to future Fearless: we chose for imm comparators and hash because:
in the future, will support the normalisation on imm objects
sorting a list and having it 'stop being sorted' or finding the max element
and having it 'not so max any more' can be buggy
In the future currentMax, currentSort etc could exist using <code>CurrentOrder[X]</code> or similar.</p>
</blockquote>
<blockquote>
<p>Map/Set can be optimised by computing the actual hash table when the first <code>.get</code> is called.
In this way Maps/sets that are just <code>.flow</code> around, will be as fast as lists.
Issue: how to remove duplicates without making the hash table</p>
</blockquote>
<p>The standard library makes it easy to add comparison operations like <code>==</code>, <code>!=</code>, <code>&lt;=</code> and so on using the types <code>Order</code> and <code>Comparator</code>, as shown below.</p>
<pre><code>Order:Sealed{
  .match[R:**](m: OrderMatch[R]): R,
  &amp;&amp;(o: read F[Order]): Order -&gt; this,//very confusing
  }
OrderMatch[R:**]: { .lt: R, .eq: R, .gt: R }
OrderLt:Order{::lt }
OrderEq:Order{.match(m) -&gt; m.eq, &amp;&amp;(o)-&gt; o# }
OrderGt:Order{::gt }

Order[T]: {
  &lt;=&gt;(other: T): Order //only abstract method for this &lt; other, this == other, this &gt; other
   ==(other: T): Bool -&gt; this &lt;=&gt; other .match{ .lt-&gt;False, .eq-&gt;True, .gt-&gt;False},
   &lt;=(other: T): Bool -&gt; this &lt;=&gt; other .match{ .lt-&gt;True,  .eq-&gt;True, .gt-&gt;False},
   &gt;=(other: T): Bool -&gt; this &lt;=&gt; other .match{ .lt-&gt;False, .eq-&gt;True, .gt-&gt;True },
    &lt;(other: T): Bool -&gt; this &lt;=&gt; other .match{ .lt-&gt;True,  .eq-&gt;False,.gt-&gt;False},
    &gt;(other: T): Bool -&gt; this &lt;=&gt; other .match{ .lt-&gt;False, .eq-&gt;False,.gt-&gt;True },
   !=(other: T): Bool -&gt; this &lt;=&gt; other .match{ .lt-&gt;True,  .eq-&gt;False,.gt-&gt;True },
  }
Comparator[T]:F[T,T,Order],F[T,Order[T]]{
  #(t1)-&gt;{t2-&gt;this#(t1,t2)},
  &amp;&amp; (other: Comparator[T]): Comparator[T] -&gt; {a,b -&gt; this#(a,b) &amp;&amp; {other#(a,b)}}
  }
</code></pre>
<p>There are three kinds of <code>Order</code>, for less then, equal or greater than.
A type <code>T</code> can implement <code>Order[T]</code> to make itself ordered. Alternatively, we can implement <code>Comparator[T]</code> to compare two instances of type <code>T</code>.
The <code>Comparator[T]</code> type extends function <code>F[T,T,Order]</code>, but also function <code>F[T,Order[T]]</code>.
The idea is that an <code>Order[T]</code> is just a comparator that knows the first element to compare.
In this way when we require to compare elements of type <code>T</code>, we can just require a <code>F[T,Order[T]]</code>, and if <code>T</code> is ordered, we can just pass the identity function <code>{::}</code>; otherwise we can write a comparator by hand doing <code>Comparator[T]{a,b-&gt;...}</code>.
To make this more clear: methods needing to compare elements will often require a <code>F[T,Order[T]]</code>.
If our actual <code>T</code> implements order, we can simply pass <code>{::}</code>; inference will expand it to <code>Anon:F[T,Order[T]]{x-&gt;x}</code>.
In the code examples below we will see a lot of <code>{::}</code> and they all expand in this way.</p>
<p><code>Order</code> and <code>Comparator[T]</code> support method <code>&amp;&amp;</code> to facilitate ordering on multiple criteria.
For example, if we prefer fast cars, and we like them red if they are equally fast, we can first compare cars using their speed, and then if the speed ordering gets <code>OrderingEq</code>, we may want to run an ordering on the colour.</p>
<p>As you can see, by implementing <code>Order[T]</code> we get a lot of utility methods to check for equality and ordering.</p>
<p>Below we show how to make a Comparator comparing two persons by age and then by age and name size.</p>
<pre><code>Persons:{#(name:Str, age:Nat):Person -&gt; Person{.name: Str -&gt; name,  .age: Nat -&gt; age }}
Older:Comparator[Person]{ p1,p2 -&gt; p1.age &lt;=&gt; (p2.age) }
OlderLonger:Comparator[Person]{ p1,p2 -&gt; p1.age &lt;=&gt; (p2.age) &amp;&amp; {p.name.size &lt;=&gt; (p2.name.size)} }
</code></pre>
<p>It is often the case that to compare elements we can reuse and compose existing comparators.
Below we can see the Comparators factory, supporting just that.</p>
<pre><code>Comparators:{//Is this really useful? -is this used somewhere?
  #[T](o: F[T, Order[T]]): Comparator[T] -&gt;
    {t1,t2-&gt;o#(t1)&lt;=&gt;(t2)},

  #[A,T](f: F[T,A],o: F[A,Order[A]]): Comparator[T] -&gt;
    {t1,t2 -&gt; o#(f#t1) &lt;=&gt; (f#t2)},
  #[A,B,T](
      fa: F[T,A],oa:F[A,Order[A]],
      fb: F[T,B],ob:F[B,Order[B]],
      ): Comparator[T] -&gt;
    {t1,t2-&gt;oa#(fa#t1) &lt;=&gt; (fa#t2) &amp;&amp; { ob#(fb#t1) &lt;=&gt; (fb#t2) }},
  ...//more overloads for more comparators components
  }
</code></pre>
<p>If we have a way <code>o</code> to convert a <code>T</code> into an <code>Order[T]</code>, for example the identity function, we can make a comparator by doing <code>Comparators#{..}</code>.
If we want to compare a <code>T</code>, we know how to view a <code>T</code> as an <code>A</code>, and we can order an <code>A</code>, we can compare a <code>T</code> as an <code>A</code> by doing for example <code>Comparators#({::age},{::})</code>.
If we have multiple observations we can combine them. For example if we want to compare persons by name and age we can do</p>
<pre><code>Comparators#({::name},{::},  {::age},{::})
//equivalent to
Comparator[Person]{p1,p2 -&gt; p1.name &lt;=&gt; (p2.name)} &amp;&amp; {p1,p2 -&gt; p1.age &amp;&amp; (p2.age)}
</code></pre>
<p>Below we show how to implement Order[T] for Person.</p>
<pre><code>Persons:{#(name:Str, age:Num):Person -&gt; Person:Order[Person]{
  .name: Str -&gt; name,
  .age: Nat -&gt; age,
  &lt;=&gt;(other)-&gt;this.age &lt;=&gt; (other.age) &amp;&amp; {this.name &lt;=&gt; (other.name)},
  }}
</code></pre>
<p>As you can see, we use &amp;&amp; to combine orderings.
We could instead use Comparators</p>
<pre><code>&lt;=&gt;(other)-&gt;Comparators#({::age},{::},  {::name},{::})#(this,other),//using comparator
</code></pre>
<p>As you can see, in this case it is not much more compact.
We can pass {::} as the even parameters because both Num and Str implement Order.</p>
<h3>Comparators and Flows: <code>.max</code>, <code>.min</code>, <code>.sort</code> and <code>.distinct</code></h3>
<p><code>Flow[E]</code> offers methods <code>.max</code>, and <code>.min</code> to find the biggest and smallest element <code>E</code>.
Finding the max from some elements is not as obvious as it looks: there are two main corner cases:
The flow may be empty. In this case, there is no such thing as a biggest/smallest element.
The flow can contain multiple elements that are equally the biggest/smallest.
Given this, the best design for <code>.max</code> and <code>.min</code> is to work as filters, and just remove all the elements that are not the max or the min.
In this way, the empty flow would stay empty, and all the biggest/smallest elements would be preserved.
There are many overloads of the methods <code>.max</code> and <code>.min</code>, mimicking the parameters and behaviour of <code>Comparators</code>.
Assuming a car type with a <code>Person</code> driver, here you can see some interesting usage examples.</p>
<pre><code>myCars.flow
  .max{::}//if Car implements Order[Car]
  .list //to get the list of all the max cars
myCars.flow
  .max({::driver},{::})//comparing the drivers. Ok since Person implements Order[Person]
  .get //this requires that there is exactly one max
myCars.flow
  .max({::driver},Older) //here we check using the Older comparator
  .opt//this requires that there is exactly zero or one max
myCars.flow
  .max({::driver.name},CaseUnsensitiveComparator,  {::driver.age},{::}) //here names ignoring case
  .first //this gives us an Optional[Car] and allows for further max cars to be discarded.

myCars.flow
  .max({::driver.name},CaseUnsensitiveComparator)
  .max({::driver.age},{::})//this example has the same behaviour of the one above
  .first//like with .filter: we can divide two conditions on two calls if we prefer

myCars.flow
  .max Comparator[Car]{c1,c2-&gt;...}// to write a comparator by hand
  .min {::} //to use the conventional comparator on the equally maximal cars
  .list
</code></pre>
<p>Flows offer method <code>.sort</code> to sort the elements.
It takes the same parameters as <code>.max</code>/<code>.min</code>.</p>
<p>Flows also offer method <code>.distinct</code> to remove duplicates. Again it takes the same parameters as <code>.max</code>/<code>.min</code>/<code>.sort</code>.</p>
<h3>Maps, sets and hashing.</h3>
<p>Hash maps (or hash tables) are one of the most popular data structures in programming.
They are a data structure that stores key-element pairs, allowing for fast retrieval of elements based on keys. It uses a hash function to compute an index (or &quot;hash&quot;) from each key, which determines where the element is stored in a large private list. This allows for nearly constant-time complexity for lookups.
Fearless <code>Map[K,E]</code> is a hashmap. We have already seen that stacks and lists contain elements. Maps also contain elements, but connected to keys. Maps are a way to link keys to values, similar to how a dictionary associates words with definitions. For example, a map could link a person's name (the key) to their phone number (the element).</p>
<p>It’s no coincidence that we have both a <code>Map[K,E]</code> type and a <code>Flow[E].map</code> method.
They both represent the idea of connecting one kind of value with another kind.
The .map method transforms a value representing the input of one stage of a computation into a value representing the output of such computation.
In a similar way, the <code>Map[K,E]</code> type holds a mapping between keys and elements, connecting distinct pieces of data.</p>
<p>As mentioned, <code>Map[K,E]</code> needs a hash function for the key <code>K</code>. The <code>OrderHash[T].hash</code> method plays this role by computing a numeric &quot;summary&quot; of an object. Although it's impossible for a hash function to uniquely identify each distinct object due to the infinite number of possible objects and the finite number of Nat values, a well-designed hash function approximates this by minimising situations where distinct objects have the same hash value. Objects are considered distinct if the <code>==</code> operation returns false.
Two objects that are equal via <code>==</code> must have the same hash value. This consistency is required for the map to work correctly.
Implementing the <code>.hash</code> method by returning zero is inefficient but technically correct: since all objects will have the same hash code, all equal objects will also trivially have the same hash code.
The map attempts to use the hash code as a fast screening test to quickly differentiate objects, and uses the slower <code>==</code> only when needed.
The default zero <code>.hash</code> method de facto disables this crucial optimisation. Instead, a good hash function spreads out objects evenly across the Nat numbers  to maximise the efficiency of the map operations.
Having the <code>.hash</code> method within the <code>OrderHash[T]</code> type helps maintain alignment between the behaviours of hashing and equality. By encapsulating both within the same type, it simplifies the enforcement of the principle that equal objects must have identical hash codes, thereby supporting more predictable and reliable map behaviour.</p>
<p>Below we show how we can use the <code>Hasher</code> type to define a good <code>.hash</code> method for Person.</p>
<blockquote>
<p>Nick: still does not like this java-style hash but lets move on for now (something something mut Summeriser[T])</p>
</blockquote>
<pre><code>OrderHash[T]:Order[T]{ .hash(h:Hasher): Nat }
Hasher:{
  #[A,B](a: OrderHash[A], b: OrderHash[B]): Nat -&gt; a.hash(this) * 31 + (b.hash(this)),
  #[A,B,C](a: OrderHash[A], b: OrderHash[B], c: OrderHash[C]): Nat -&gt; ...,
  ...//more overloads to compose more values
  .nat(v:Nat):Nat-&gt;..,
  .int(v:Int):Nat-&gt;..,
  .sStr(v:Str):Nat-&gt;..,
  ...//more methods for directly hashable types
  .list[E](l:List[E],F[E,OrderHash[E]])-&gt;..,
  .opt[E](o:Opt[E],F[E,OrderHash[E]])-&gt;..,
  ..//more methods for collections
  }
//usage
Persons:{#(name:Str, age:Num):Person -&gt; Person:OrderHash[Person]{
  .name: Str -&gt; name,
  .age: Nat -&gt; age,
  &lt;=&gt;(other)-&gt;this.age&lt;=&gt;(other.age) &amp;&amp; {this.name&lt;=&gt;(other.name)},
  .hash(h)-&gt;h#(this.age,this.name),//just list the relevant components
  }
}
</code></pre>
<p>With such a person type, we can define a Map from persons to address:</p>
<pre><code>Maps#({::},   // this is expanded as F[Person,OrderHash[Person]]{x-&gt;x}
  Persons#(`Bob`,25),`Toronto 34b Warden St.`,
  Persons#(`Alice`,34),`Wellington 134 Kelburn parade`,
  ...
  )
</code></pre>
<p>As you can see, maps take functions to get the order and the hash.
<code>Map[K,E]</code> has many operations, similarly to <code>List[E]</code>.
We have <code>.size</code>, <code>.isEmpty</code> and <code>.get</code>.
However, <code>.get</code> does not take an index of type <code>Nat</code> but a key of type <code>K</code>.
For example, with the map declared above</p>
<pre><code>myMap.isEmpty //false
myMap.size //2
myMap.get(Persons#('Alice',34)) // 'Wellington 134 Kelburn parade'
</code></pre>
<p>If the key is not present in the map, .get will cause an error.
We can instead use .opt to extract an optional Opt[E] result. For example</p>
<pre><code>myMap.get(Persons#('Neil Armstrong',38)) // error
myMap.opt(Persons#('Neil Armstrong',38)).or 'Moon' // alternative default value.
</code></pre>
<p>Maps can have <code>mut</code>, <code>imm</code> or <code>read</code> elements; but only immutable keys. This is because the implementation of <code>Map[K,E]</code> needs to assume that the result of <code>.hash</code> and <code>==</code> is consistent over time.</p>
<p>We can flow on a map, but since both keys and elements are present, the flow method takes a function mapping keys and elements in some value.
For example
<code>myMap.flow{k,e-&gt; k.name + e }.list</code>
will return <code>List#('BobToronto 34b Warden St.','AliceWellington 134 Kelburn parade')</code></p>
<p>Note how the order of the flow is the same as the insertion order.</p>
<p>We can also create a map from a flow, using method .keyElem as shown below:</p>
<pre><code>myPersons.flow
  .map{..}  //.fmap
  .filter{..}
  .keyElem({::},{//.mapping ? .hash?  .dict? intoMap? just .map/2 vs .map/1
    .key(e)-&gt;e.name,
    .elem(e)-&gt;e,
    })
</code></pre>
<p>Here we pass two parameters: a function from <code>K</code> to <code>Order[K]</code>, that as usual can be the identity if our keys implement <code>Order[K]</code>, and a literal specifying how to create the key and the element from the objects inside the flow.</p>
<p>Finally, sets of type <code>Set[K]</code> are another application of hashing. Instead of mapping keys to elements, it simply remembers if a key is present or not. That is, <code>Set[K]</code> most important methods are <code>.size</code>, <code>.isEmpty</code> and <code>.contains</code>.
Sets also support <code>.flow</code>, working exactly as for lists. Again, the order of the flow is the same as the insertion order.
See below some examples of using sets.</p>
<pre><code>Sets#({::},1,2,3,4,5)//set of 5 numbers
Sets#(Comparator[Str]{s1,s2-&gt;s1.size&lt;=&gt;s2.size},'a','aa','aaaaa')//Does not compile.
Sets#(StrSizeOrder,'a','aa','aaaaa')//good
StrSizeOrder:F[Str,Order[Str]]{s1-&gt;{
  &lt;=&gt;(s2) -&gt; s1.size &lt;=&gt; (s2.size),
  .hash   -&gt; s1.size.hash,
  }}//Here we manually define an ordering for strings using their size.
</code></pre>
<p>Note how our first attempt for a set with custom comparison does not compile.
That comparator is a function from <code>Str</code> to <code>Order[Str]</code>, but here we need an <code>OrderHash[Str]</code>.</p>
<p>We can create a set from a flow by calling <code>.set{::}</code>, or passing a specific order.</p>
<p>In the same way there is an <code>UList[E]</code> type that is an updatable variant of <code>List[E]</code>, there are types <code>UMap[K,E]</code> and <code>USet[E]</code>. As for <code>UList[E]</code>, they are rarely used so we will discuss them (much) later.</p>
<h3>List, Opt and ordering.</h3>
<p>Finally, <code>List[E]</code> and <code>Opt[E]</code> do not implement Order or OrderHash.
They do not need to and they may not contain ordered elements.
However, Order is quite useful.
If I want to sort a list of ordered elements I can do
myList.flow
.sort{::}
.list</p>
<p>How to sort a list of lists?
We can use the method <code>List[E].order</code>, that takes a function from <code>E</code> to <code>Order[E]</code>. That is, if myList is a <code>List[List[E]]</code> and <code>E</code> implements <code>Order[E]</code> or <code>OrderHash[E]</code>, we can simply write:</p>
<pre><code>myList.flow
  .sort{::order{::}}
  .list
</code></pre>
<p>The same exact code would work for a <code>List[Opt[E]]</code>.</p>
<p><code>Set[E]</code> knows how to order its keys, so <code>Set[E]</code> implements <code>OrderHash[E]</code>.
A map knows how to order the keys, but not the elements, so also map offers method <code>.order</code>.</p>
<p>This is similar to how all of those types can be converted into strings:
You just need to provide a function from <code>E</code> to <code>ToStr</code>.
<code>myList.str{::}</code> will work if myList is of type <code>List[E]</code> and <code>E</code> implements <code>ToStr</code>. If myList is of type <code>List[List[E]]</code> we would need to write
<code>myList.sStr{::str{::}}</code>.
Overall, this is similar to how <code>.as</code> works for nested lists.</p>
<blockquote>
<p>Note UList should start with a Num current size AND should allow for 'holes', so .get
can give exception in the middle of present items.
Choice for strings with data obtained by string interpolation:
1 # string interpolation does not make strings but Proc:HasStr
2 # Proc:Str  ///winner (slow when recomputing, but very memory efficient when stored)
3 # inject Str! on naked #</p>
</blockquote>
      <div class="nav-links">
      <a href="23_01.html">Previous</a> <span class="disabled">Next</span>
      </div>
    </div>
  </body>
</html>
