<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Chapter 3 :: Show All Tanks</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div id="sidebar">
  <div class="sidebar-entry"><a href="01_01.html">Preface :: Fearless: Zero to Hero</a></div>
<div class="sidebar-entry"><a href="02_01.html">Chapter 1 :: Directions</a></div>
<div class="sidebar-entry"><a href="03_01.html">Chapter 1 :: Basic code reuse</a></div>
<div class="sidebar-entry"><a href="04_01.html">Chapter 1 :: Rotations</a></div>
<div class="sidebar-entry"><a href="05_01.html">Chapter 1 :: Finite numbers</a></div>
<div class="sidebar-entry"><a href="06_01.html">Chapter 1 :: Strings</a></div>
<div class="sidebar-entry"><a href="07_01.html">Chapter 1 :: Types and Meaning</a></div>
<div class="sidebar-entry"><a href="08_01.html">Chapter 1 :: Terminology Recap</a></div>
<div class="sidebar-entry"><a href="09_01.html">Chapter 2 :: Generic Types</a></div>
<div class="sidebar-entry"><a href="10_01.html">Chapter 2 :: Booleans</a></div>
<div class="sidebar-entry"><a href="11_01.html">Chapter 2 :: Optionals</a></div>
<div class="sidebar-entry"><a href="12_01.html">Chapter 2 :: Peano numbers</a></div>
<div class="sidebar-entry"><a href="13_01.html">Chapter 2 :: Stack</a></div>
<div class="sidebar-entry"><a href="14_01.html">Chapter 2 :: Operations on Sequences</a></div>
<div class="sidebar-entry"><a href="15_01.html">Chapter 2 :: Locals</a></div>
<div class="sidebar-entry"><a href="16_01.html">Chapter 2 :: Tanks Game</a></div>
<div class="sidebar-entry"><a href="17_01.html">Chapter 3 :: ImplementingFromScratch</a></div>
<div class="sidebar-entry"><a href="18_01.html">Chapter 3 :: Promotions</a></div>
<div class="sidebar-entry"><a href="19_01.html">Chapter 3 :: Packages</a></div>
<div class="sidebar-entry"><a href="20_01.html">Chapter 3 :: ObjectCapabilities</a></div>
<div class="sidebar-entry"><a href="21_01.html">Chapter 3 :: NewOptBool</a></div>
<div class="sidebar-entry"><a href="22_01.html">Chapter 3 :: Show Tanks</a></div>
<div class="sidebar-entry"><a href="23_01.html">Chapter 3 :: Show All Tanks</a></div>
<div class="sidebar-entry"><a href="24_01.html">Chapter 3 :: Collections</a></div>
<div class="sidebar-entry"><a href="25_01.html">Chapter 4 :: Errors are good!</a></div>
<div class="sidebar-entry"><a href="26_01.html">Chapter 4 :: Enumerations</a></div>
<div class="sidebar-entry"><a href="27_01.html">Chapter 4 :: Action</a></div>
<div class="sidebar-entry"><a href="28_01.html">Chapter 4 :: Serialising Tanks</a></div>

  </div>
  <div id="content" class="markdown-content">
<h3>Visualising a full tank game.</h3>
<p>How to visualise a full tank game? Those tanks can be in any position; it would be impractical to display a grid able to contain any x/y number coordinates. For simplicity, we will just display the grid with x,y ranging from zero to nine inclusive.
To do this, we will use mutation:</p>
<ul>
<li>We will first create a list of lists of variable strings, initially representing an empty grid.</li>
<li>We will then fill it by looking at all the tanks.</li>
<li>Finally, we will concatenate all the results into a big string.</li>
</ul>
<p>Since each tanks is represented as 3 lines, we will have a grid 30 * 10.
Initially, every cell will contain <code></code>: six spaces, representing the absence of a tank. This is because each tank line is 6 characters.</p>
<pre><code>//----------------------------------
//File _tank_game/print_game.fear
TanksToS: F[List[Tank],Str]{ ts -&gt; Block#
  .let res = {0.rangeUntil(30).map{_-&gt;this.newLine}.list }
  .do{ ts.flow.forEach{ t -&gt; Block#
    .let x= { t.position.x }
    .let y= { t.position.y }
    .if {x.inRange(0,10).not} .done
    .if {y.inRange(0,10).not} .done
    .do{ res.get(y * 3)    .get(x).set(t.repr1) }
    .do{ res.get(y * 3 + 1).get(x).set(t.repr2) }
    .do{ res.get(y * 3 + 2).get(x).set(t.repr3) }
    .done
    }}
  .return { res.flow.map{::.flow.map{::.get}.join(``)}.join(``|) };
  read .newLine: mut List[mut Var[Str]] -&gt; 0.rangeUntil(10).map{ _ -&gt; Vars#(`      `)}.list;
  }
PrintGame: {
  mut .out: mut Output;
  mut .singleLine(ts: List[Tank]): Void -&gt; this.out.println(TanksToS#(ts));
  mut .lines(rounds: Nat, ts: List[Tank]): Void -&gt; Block#
    .var current= {ts}
    .return{ 0.rangeUntil(rounds).forEach{step -&gt; Block#(
      this.out.println(`Step `+step|),
      this.out.println(`------------------------------------------------------------`|),
      this.singleLine(current.get),
      this.out.println(`------------------------------------------------------------`|),
      current.set(NextState#(current.get))
      )}}
  }
//----------------------------------
//File _tank_game/_rank_app.fear
Test: Main {sys -&gt; Block#
  .let out= {sys.out}
  .let in= {sys.inputCursor# !}
  .let game= {mut ReadGame{in}.read}//ReadGame omitted for now
  .return{ mut PrintGame{out}.lines(50,game) }
  }
</code></pre>
<p>As you can see, we omitted the code reading the initial game state.
This is because in order to read data from files there is still quite some content that we need to learn. We will handle that in Chapter 4.
Assuming a properly implemented <code>ReadGame</code>, this code could print something like the following:</p>
<pre class="code-50"><code>
Step 5
------------------------------------------------------------
 / - \       / - \
 | > |       - V |
 \ | /       \ _ /



       / - \ 
       | V | 
       \ | / 
                                     / - \
                                     | < |
                                     \ | /
             / | \ 
             | > | 
             \ _ / 



 / - \       / - \
 | > |       - V |
 \ | /       \ _ /



                                     / - \
                                     | < |
                                     \ | /
------------------------------------------------------------

Step 6
------------------------------------------------------------
       / - \     
       | > |     
       \ | /     
             / - \
             - V |
             \ _ /
 


       / - \                   / - \
       | V |                   | < |
       \ | /                   \ | /
                   / | \  
                   | > | 
                   \ _ / 



       / - \
       | > |
       \ | /
             / - \
             - V |
             \ _ /
                               / - \
                               | < |
                               \ | /
------------------------------------------------------------
</code></pre>
<p>Where tanks can be displayed on the screen, showing the various steps of the game</p>
<p>We now focus on those two lines:</p>
<pre><code>  .let res = {0.rangeUntil(30).map{_-&gt;this.newLine}.list }
  ...
  read .newLine: mut List[mut Var[Str]] -&gt; 0.rangeUntil(10).map{ _ -&gt; Vars#(`      `)}.list;
</code></pre>
<ul>
<li>Here we use <code>.rangeUntil</code> to create a flow containing the numbers 0..29.</li>
<li>Then we use <code>.map</code> to call <code>this.newLine</code> 30 times.
Note how we use the <code>_</code> to show that we do not need the current element of the flow (a number in 0..29).</li>
<li>Finally, we use <code>.list</code> to turn the flow into a list.</li>
<li><code>.newLine</code> internally does a very similar work:
We range from 0..9 and for each of those we create a <code>Var</code> initialised with six spaces.
That is, the type of <code>res</code> is <code>mut List[mut List[mut Var[Str]]]</code>.
This is a large and intricate type, representing a list of list of variable strings.
The next section will discuss <code>List</code>s and <code>Flow</code>s in the detail.</li>
</ul>
<p>The code shown below uses <code>res</code> to represent a grid of information, that can be updated as needed.</p>
<pre><code>    .let x= { t.position.x }
    .let y= { t.position.y }
    .if {x.inRange(0,10).not} .done
    .if {y.inRange(0,10).not} .done
    .do{ res.get(y * 3)    .get(x).set(t.repr1) }
    .do{ res.get(y * 3 + 1).get(x).set(t.repr2) }
    .do{ res.get(y * 3 + 2).get(x).set(t.repr3) }
</code></pre>
<p>This code runs <code>.forEach</code> of the tanks <code>t</code> in <code>ts</code>
<code>x/y</code> are just short names for the coordinates of <code>t</code>.
If <code>x</code> or <code>y</code> are <code>.not</code> in the visualized range, we do not represent tank <code>t</code> on our board <code>res</code>.
Otherwise, we write the three lines representing <code>t</code> on the appropriate position on <code>res</code>.
Note how we call <code>.get(..).get(..).set(..)</code>
to access two layers of <code>List</code> and then set a new value in our variable.</p>
<p>What we are creating now is basically a 'text art' based game.
Those were popular in the (far) past. Of course Fearless supports proper graphics, and we will see how to render nice looking images of tanks later on; but this way of printing the 'current screen' line by line is how those more fancy graphic systems work too under the hood.
Here we use characters as graphical symbols, they use (much smaller) coloured pixels as graphical symbols.</p>
<p>But the idea of doing graphics by using a grid of graphical symbols is the same,
and the struggle to decide what symbol to place in each location is very similar too.</p>
<p>That is, the techniques and mindset shown here do scale to full modern 2-D, or even 3-D graphics.
The computer screen is conceptually accessed as a large <code>mut List[mut List[mut Var[Color]]]</code>
and the computer is simply insanely fast at switching those colours around creating the illusion of movement.</p>
<p>When wanting to display shapes on the screen, the logic will look a lot like what we had for our tanks: forall shapes to display, display the shape.
To display an individual shape: for all the parts of the shape: display the individual part (the three lines of the tank in our example).
The act of displaying a shape part is the act of setting new colours in specific places in the large <code>mut List[mut List[mut Var[Color]]]</code> screen.</p>
<p>Hopefully this removes another layer of mystery on how computers works, and the realisation that those little pixels are indeed explicit entities that operations in the computer are able to update fast enough to create the illusion of movement clarifies in a visceral way how fast those computers are.</p>
      <div class="nav-links">
      <a href="22_01.html">Previous</a> <a href="24_01.html">Next</a>
      </div>
    </div>
  </body>
</html>
